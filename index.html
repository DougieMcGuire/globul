<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Humanized Chatbot</title>
<style>
  body { font-family: Arial, sans-serif; background: #f4f4f4; display: flex; flex-direction: column; align-items: center; padding: 20px; }
  #chat { width: 500px; height: 400px; border: 1px solid #ccc; background: #fff; padding: 10px; overflow-y: scroll; margin-bottom: 10px; }
  .message { margin: 5px 0; }
  .user { font-weight: bold; color: blue; }
  .bot { font-weight: bold; color: green; }
  #inputArea { display: flex; width: 500px; }
  #input { flex: 1; padding: 10px; }
  #send { padding: 10px; }
</style>
</head>
<body>

<div id="chat"></div>
<div id="inputArea">
  <input type="text" id="input" placeholder="Type your message here..." />
  <button id="send">Send</button>
</div>

<script>
const apiKey = "G7mssh3Pay81qZfJ"; // Burner API key
const model = "mistral"; // Choose model
const systemPrompt = "You are a helpful assistant."; // Optional system prompt
let conversation = JSON.parse(localStorage.getItem('conversation')) || [];

function humanize(text) {
    // Random capitalization
    text = text.split('').map(c => Math.random() < 0.1 ? c.toUpperCase() : c).join('');

    // Random typos
    let words = text.split(' ');
    for (let i = 0; i < words.length; i++) {
        if (Math.random() < 0.05 && words[i].length > 3) {
            let idx = Math.floor(Math.random() * (words[i].length - 2)) + 1;
            words[i] = words[i].slice(0, idx) + words[i][idx + 1] + words[i][idx] + words[i].slice(idx + 2);
        }
    }
    text = words.join(' ');

    // Add casual filler occasionally
    if (Math.random() < 0.2) text += [" lol", " haha", " ðŸ˜…"][Math.floor(Math.random() * 3)];

    return text;
}

function buildContext() {
    // Build a string of all messages in the current conversation
    return conversation.map(entry => (entry.role === 'user' ? "User: " : "Bot: ") + entry.text).join("\n");
}

function updateChat() {
    const chatDiv = document.getElementById('chat');
    chatDiv.innerHTML = '';
    conversation.forEach(entry => {
        const div = document.createElement('div');
        div.className = 'message ' + entry.role;
        div.textContent = entry.role === 'user' ? 'You: ' + entry.text : 'Bot: ' + entry.text;
        chatDiv.appendChild(div);
    });
    chatDiv.scrollTop = chatDiv.scrollHeight;
}

async function sendMessage() {
    const input = document.getElementById('input');
    const userText = input.value.trim();
    if (!userText) return;
    conversation.push({ role: 'user', text: userText });
    updateChat();
    input.value = '';

    try {
        // Build context for current conversation
        const context = buildContext();

        // Call Pollinations API
        const response = await fetch(`https://text.pollinations.ai/${encodeURIComponent(context)}?model=${model}&system=${encodeURIComponent(systemPrompt)}`, {
            headers: { 'Authorization': 'Bearer ' + apiKey }
        });
        const data = await response.json();
        let botText = data.text || "Oops, I didn't get that.";
        botText = humanize(botText);
        conversation.push({ role: 'bot', text: botText });

        // Save persistent conversation
        localStorage.setItem('conversation', JSON.stringify(conversation));

        updateChat();
    } catch (err) {
        conversation.push({ role: 'bot', text: "Error fetching response ðŸ˜…" });
        updateChat();
        console.error(err);
    }
}

document.getElementById('send').addEventListener('click', sendMessage);
document.getElementById('input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') sendMessage();
});

// Initial display
updateChat();
</script>

</body>
</html>
